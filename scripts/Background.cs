using System;
using System.Collections.Generic;
using System.Runtime.InteropServices.JavaScript;
using System.Threading.Tasks;
using Godot;
using Godot.Collections;
using MiningGame.scripts.cutout;

namespace MiningGame.scripts;

public partial class Background : Sprite2D
{
    [Signal]
    public delegate void ImageChangeEventHandler(Image newImage);

    [Signal]
    public delegate void BackgroundGenerationCompletedEventHandler(ImageTexture backgroundGenerated);

    private GodotThread backgroundGenerationThread = new();
    private List<Vector2> cutoutsToRender = [];
    private List<int> cutoutIndices = [0];
    
    public void Initialize()
    {
        Sprite2D render = GetRender();
        render.Scale = new Vector2(6, 6);
        
        backgroundGenerationThread.Start(Callable.From(() => new BackgroundGenerator(
            new Vector2I(Constants.ScreenWidth, Constants.ScreenHeight)).GenerateBackground()));
    }

    /// <summary>
    /// Waits for the background Image to be generated and then performs the nessacary scaling/rendering of the image.
    /// This Sprite's texture is set to the result and the ImageChanged signal is emitted with the result.
    /// </summary>
    public async void WaitForRender() // TODO Return Task after migrating Wall to C#
    { 
        ImageTexture generatedBackground = backgroundGenerationThread.WaitToFinish().As<ImageTexture>();

        await Render(generatedBackground);
        GetRender().Scale = new Vector2(1, 1); // Reset the scaling because the "screenshot" is already resized.
        
        EmitSignalImageChange(Texture.GetImage());
    }
    
    // Called when CutoutQueue.RenderCutout Signal is emitted. This is needed because Godot doesn't like async methods.
    public void OnCutoutQueueRenderCutoutHandler(Vector2[] cutoutVertices)
    {
        _ = OnCutoutQueueRenderCutout(cutoutVertices);
    }
    
    /// <summary>
    /// Adds transparency to the background image for the area provided in the cutoutPolygon parameter. This provides
    /// the effect of part of the wall being "cut out".
    /// This transparency is generated by performing the following steps:
    ///     1. Set the texture of a sprite within a subview to the current background image.
    ///     2. Apply a shader to the sprite, this shader sets all pixels within the provided polygon to transparent.
    ///     3. "Screenshot" the sprite through the subview, returning a new texture.
    ///     4. Set this sprite's texture to the "screenshot", this is the new background image.
    /// Note that by reusing the background image that has already been "cut" allows us to continue to add holes without
    /// passing excessive data to the shader; The image is "saved" each time. 
    /// </summary>
    /// <param name="cutoutPolygon">The polygon to cut out of the background texture</param>
    public async Task OnCutoutQueueRenderCutout(Vector2[] cutoutPolygon)
    {
        cutoutsToRender.AddRange(cutoutPolygon);
        cutoutIndices.Add(cutoutIndices[^1] + cutoutPolygon.Length);

        await Render(Texture);
        
        // Clear the shader parameters because the image is "saved".
        cutoutsToRender = [];
        cutoutIndices = [0];
    }

    /// <summary>
    /// Renders the provided texture onto a sprite within a subview, I then modify this sprite to provide two results:
    ///     1. Scaling up the texture. Currently, I scale the texture by x6.
    ///     2. Generate the "cut out" in the background so it seems like part of the wall has been removed.
    /// Details for how I generate the "cut out" effect can be found in the comment above OnCutoutQueueRenderCutout().
    ///
    /// The resulting texture is set to this sprite's texture.
    /// </summary>
    /// <param name="texture">The texture to render and "modify".</param>
    private async Task Render(Texture2D texture)
    {
        Sprite2D render = GetRender();
        render.Texture = texture;
        
        SetShadowParameters(render);

        var subViewport = GetSubViewport();
        Texture = await GetSubviewTexture(subViewport);
    }

    private async Task<ImageTexture> GetSubviewTexture(SubViewport subViewport)
    {
        subViewport.SetUpdateMode(SubViewport.UpdateMode.Once);
        
        // Wait for the Draw events to complete so that we can sure that the "screenshot" will actually capture something.
        await ToSignal(RenderingServer.Singleton, RenderingServerInstance.SignalName.FramePostDraw);
        
        return ImageTexture.CreateFromImage(subViewport.GetTexture().GetImage());
    }
    
    private void SetShadowParameters(Sprite2D render)
    {
        ((ShaderMaterial)render.Material).SetShaderParameter("polygon_points", Variant.From(cutoutsToRender.ToArray()));
        ((ShaderMaterial)render.Material).SetShaderParameter("polygon_indices", Variant.From(cutoutIndices.ToArray()));
        ((ShaderMaterial)render.Material).SetShaderParameter("polygon_count", Variant.From(cutoutIndices.Count));
        render.QueueRedraw();
    }

    private SubViewport GetSubViewport()
    {
        return GetNode<SubViewport>("subview");
    }

    private Sprite2D GetRender()
    {
        return GetNode<Sprite2D>("subview/render");
    }
}

public class BackgroundGenerator(Vector2I windowSize)
{
    private Vector2I windowSize = windowSize;
    
    private static readonly Color BackgroundColor = Color.Color8(47, 54, 58);
    private static readonly Color RockBorderColor = Color.Color8(15, 20, 26);
    private static readonly Color RockColor = Color.Color8(20, 27, 35);


    public ImageTexture GenerateBackground()
    {
        /*
         * Due to background generations occuring in the background, calls to the base rng will occur at random times,
	     * causing undeterministic rng/games. We use a seperate RNG for backgrounds to fix this. 
         */
        RandomNumberGenerator rng = new();
        windowSize /= 5;

        int[,] map = new int[windowSize.X, windowSize.Y];

        // Randomly allocate pixels to 1 or 0. This is our noise generator.
        TransformMap(map, _ =>
        {
            float rand = rng.Randf();
            return rand >= 0.55 ? 1 : 0;
        });
        

        // Smooth out the pixels. "If most of my neighbours are 1 then I should be 1 too". 
        // We perform two iterates because I like how it looks, increasing the iterations increases the size of the "rocks" 
        for (var i = 0; i < 2; i++) // Iterate twice
        {
            var updatedMap = new int[windowSize.X, windowSize.Y];
            
            TransformMap(updatedMap, pixel =>
            {
                int sum = GetTileSum(map, pixel.X, pixel.Y);
                return sum <= 4 ? 0 : 1;
            });
            
            map = updatedMap;
        }
        
        // Finally, convert this matrix into an image.
        // If the area is mostly "1"s then its the "background".
        // If an area is mostly "0"s but still has a few "1"s then we are on a rock boulder so give it the darkest colour.
        // Anything leftover is the inside of the rock so give it the rock colour.
        Image image = Image.CreateEmpty(windowSize.X, windowSize.Y, false, Image.Format.Rgba8);
        foreach(Vector2I pixel in ForEachPixel())
        {
            int sum = GetTileSum(map, pixel.X, pixel.Y);
                
            Color color;
            if (sum <= 4)
            {
                color = sum >= 1 ? RockBorderColor : RockColor;
            }
            else
            {
                color = BackgroundColor;
            }
            image.SetPixel(pixel.X, pixel.Y, color);   
        }

        ImageTexture texture = ImageTexture.CreateFromImage(image);

        return texture;
    }

    /// <summary>
    /// Counts the number of neighbors with the value of 1, neighbours includes diagonals.
    /// </summary>
    /// <param name="map">The matrix to scan</param>
    /// <param name="x">The X for pixel to get the neighbour count for</param>
    /// <param name="y">The Y for pixel to get the neighbour count for</param>
    /// <returns></returns>
    private int GetTileSum(int[,] map, int x, int y)
    {
        int sum = 0;
        
        for(int i = x - 1; i <= x + 1; i++)
        {
            if (i < 0 || i >= windowSize.X)
            {
                // If the x is out of bounds then all the of the y is too, so we +3 and move on to the next x. 
                sum += 3; 
                continue;
            }

            for (int j = y - 1; j <= y + 1; j++)
            {
                if (j < 0 || j >= windowSize.Y)
                {
                    sum += 1;
                }
                else
                {
                    sum += map[i, j];
                }
            }
        }

        return sum;
    }

    private void TransformMap(int[,] map, Func<Vector2I, int> transformFunction)
    {
        foreach (Vector2I pixel in ForEachPixel())
        {
            map[pixel.X, pixel.Y] = transformFunction(pixel);
        }
    }

    private IEnumerable<Vector2I> ForEachPixel()
    {
        for (int x = 0; x < windowSize.X; x++)
        {
            for (int y = 0; y < windowSize.Y; y++)
            {
                yield return new Vector2I(x, y);
            }
        }
    }
}